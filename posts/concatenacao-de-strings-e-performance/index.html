<!DOCTYPE html><html lang="en" mode="dark" > <!-- The Head v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Concatenação de strings e performance | murilo.tech</title><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Concatenação de strings e performance" /><meta name="author" content="Murilo Costa" /><meta property="og:locale" content="en_US" /><meta name="description" content="Eu acredito que a maioria das pessoas com alguma vivência na programação e que usa ou já usou Java, com certeza já ouviu falar que devemos evitar o uso de concatenação de strings na linguagem e devemos usar formas melhores como o uso do StringBuilder para casos em que será necessário concatenar grandes partes de texto, mas já parou alguma vez para entender o porquê disso? Esse é um problema que está ligado diretamente a análise de algoritmos e suas ordens, o famoso Big O, e vamos entender um pouco sobre isso no post de hoje. Vou usar o Java aqui nesse exemplo, porém o problema também existe em outras linguagens, onde cada uma provê sua própria solução. Vamos ao teste Apesar de já ter ouvido sobre essa questão diversas vezes, será que ela realmente é válida? Será que faz alguma diferença mesmo usar StringBuilder no lugar de concatenação de strings? Vamos então fazer alguns testes para verificar esse comportamento. Para testar vamos fazer um gerador de textos Lorem Ipsum aleatório, que irá gerar textos com uma quantidade definida de parágrafos, onde vamos comparar os tempos de execução em minha máquina, um i5 1.3GHz, 4GB de RAM e 128 SSD. Primeiramente vamos definir uma classe de constantes com os parágrafos Lorem Ipsum. 1 2 3 4 5 6 7 8 9 public class LoremIpsumText { public static String LOREM_TEXT_01 = &quot;Lorem ipsum dolor sit amet, consectetur ...\n&quot;; public static String LOREM_TEXT_02 = &quot;Donec a rutrum velit, eu sodales libero ...\n&quot;; public static String LOREM_TEXT_03 = &quot;Duis fringilla porttitor elit, ac conse ...\n&quot;; public static String LOREM_TEXT_04 = &quot;Fusce a euismod ante, ullamcorper variu ...\n&quot;; public static String LOREM_TEXT_05 = &quot;Lorem ipsum dolor sit amet, consectetur ...\n&quot;; } Os textos foram cortados aqui no post para não ficar muito grande. Repare que no final de cada texto existe uma quebra de linha representada por \n. A geração de parágrafos aleatórios será feita diretamente em uma enum representando os parágrafos disponíveis. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public enum LoremIpsum { LOREM_01(LoremIpsumText.LOREM_TEXT_01), LOREM_02(LoremIpsumText.LOREM_TEXT_02), LOREM_03(LoremIpsumText.LOREM_TEXT_03), LOREM_04(LoremIpsumText.LOREM_TEXT_04), LOREM_05(LoremIpsumText.LOREM_TEXT_05); private String text; private LoremIpsum(String text) { this.text = text; } public String getText() { return text; } public static LoremIpsum random() { var index = new Random().ints(0, values().length - 1) .findFirst() .getAsInt(); return values()[index]; } } Como pode ser visto na enum, cada opção mapeia para um texto diferente e o método random() traz um texto de forma aleatória. Isso nos ajuda a ter uma diversidade melhor no processo, garantindo que não ocorra nenhum vício por parte de execução do software, como cache de JVM por exemplo. Afim de termos certeza que essa geração é rápida o suficiente e não vai afetar os testes, vamos criar um teste unitário para geração e verificar o tempo decorrido. O teste unitário consistirá em obter um texto de forma aleatória e verificar se ele está de acordo com os textos disponíveis. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class LoremIpsumTest { @Test public void loremIpsumAleatorio() { var lorems = Arrays.asList( LoremIpsum.LOREM_01, LoremIpsum.LOREM_02, LoremIpsum.LOREM_03, LoremIpsum.LOREM_04, LoremIpsum.LOREM_05 ); var lorem = LoremIpsum.random(); assertTrue(lorems.contains(lorem)); } } Com esse resultado podemos ver que essa geração é extremamente rápida. Agora vamos então criar a classe que irá gerar os textos, usando concatenação de strings ou StringBuilder. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class TextGenerator { public static String generateParagraphsTextWithStringConcat(int paragraphCount) { String text = &quot;&quot;; for (int i = 0; i &lt; paragraphCount; i++) { text += LoremIpsum.random().getText(); } return text; } public static String generateParagraphsTextWithStringBuilder(int paragraphCount) { var text = new StringBuilder(); for (int i = 0; i &lt; paragraphCount; i++) { text.append(LoremIpsum.random().getText()); } return text.toString(); } } A classe acima possui somente dois métodos estáticos que fazem a mesma coisa: receber uma quantidade de parágrafos por parâmetro e então gerar textos aleatórios usando junções de parágrafos providos por LoremIpsum.random(), de acordo com a quantidade de parágrafos definida. E agora vamos aos teste finais. Os testes consistirão também de testes unitários, que irão gerar o texto com uma quantidade definida de parágrafos e depois testar a quantidade de quebras de linha no texto. Inicialmente vamos usar uma quantidade de cem parágrafos e ver o resultado. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class TextGeneratorTest { @Test public void cemParagrafosDeTextoComStringConcat() { var text = TextGenerator.generateParagraphsTextWithStringConcat(100); assertEquals(100, text.chars().filter(ch -&gt; ch == &#39;\n&#39;).count()); } @Test public void cemParagrafosDeTextoComStringBuilder() { var text = TextGenerator.generateParagraphsTextWithStringBuilder(100); assertEquals(100, text.chars().filter(ch -&gt; ch == &#39;\n&#39;).count()); } } Podemos ver na imagem que o tempo de execução foi o mesmo para as duas abordagens: 0,000 segundos. Será que então realmente não têm diferença entre elas? Vamos utilizar mil parágrafos no próximo teste. 1 2 3 4 5 6 7 8 9 10 11 12 13 public class TextGeneratorTest { @Test public void milParagrafosDeTextoComStringConcat() { var text = TextGenerator.generateParagraphsTextWithStringConcat(1000); assertEquals(1000, text.chars().filter(ch -&gt; ch == &#39;\n&#39;).count()); } @Test public void milParagrafosDeTextoComStringBuilder() { var text = TextGenerator.generateParagraphsTextWithStringBuilder(1000); assertEquals(1000, text.chars().filter(ch -&gt; ch == &#39;\n&#39;).count()); } } Opa! Agora parece que já temos uma pequena diferença, onde a abordagem com o StringBuilder continua com 0,000 segundos, mas a concatenação já está levando 419 milissegundos (0,419 segundos) de execução. Porém isso ainda não é algo que realmente faça tanta diferença assim para que seja uma recomendação levada a sério. Vamos então subir um pouco mais a quantidade de parágrafos no nosso teste final: dez mil. 1 2 3 4 5 6 7 8 9 10 11 12 13 public class TextGeneratorTest { @Test public void dezMilParagrafosDeTextoComStringConcat() { var text = TextGenerator.generateParagraphsTextWithStringConcat(10000); assertEquals(10000, text.chars().filter(ch -&gt; ch == &#39;\n&#39;).count()); } @Test public void dezMilParagrafosDeTextoComStringBuilder() { var text = TextGenerator.generateParagraphsTextWithStringBuilder(10000); assertEquals(10000, text.chars().filter(ch -&gt; ch == &#39;\n&#39;).count()); } } E então finalmente temos nossa grande diferença. Usando o StringBuilder temos um tempo de execução de 0,007 segundos (7 milissegundos), enquanto que a concatenação levou longos 26,220 segundos, um tempo imensamente maior que o da primeira abordagem, o que comprova que realmente o StringBuilder é a melhor alternativa principalmente para textos longos. Mas por quê isso acontece? Entendendo strings Antes de falar sobre o problema vamos mostrar algumas coisas sobre as strings e como elas funcionam. A maioria das linguagens (principalmente as compiladas) possuem diferentes tipos de atributos, geralmente chamados de tipos de variáveis, onde eles são separados em primitivos e complexos. Os primitivos são os tipos mais básicos das linguagens, no caso do Java eles são a menor representação que um tipo pode ter, que são os tipos int, short, long, byte, float, double, boolean, char e etc, e os tipos complexos são definições criadas utilizando a linguagem e que agrupam e/ou manusei am esses tipos primitivos, onde em Java as classes, enums e interfaces são utilizadas para esse propósito. Para exemplificar podemos ter os atributos primitivos int codigo e double valor para representar o código e valor de um produto, e podemos então criar um tipo complexo que é uma classe Produto contendo esses atributos primitivos, o que nos permite manusear os tipos primitivos de forma agrupada no tipo complexo. 1 2 3 4 5 6 7 8 public class Produto { int codigo; double valor; } var produto = new Produto(); produto.codigo = 1; produto.valor = 10.0; As strings em Java funcionam dessa mesma forma, onde uma String é uma classe que representa um conjunto de letras, armazenadas no formato de um vetor de caracteres, ou seja um char[] texto. Basicamente quando uma String é declarada, internamente é criado um vetor contendo os caracteres do texto e esse vetor nunca muda, pois as strings são imutáveis, ou seja não podem ser modificadas, e isso implica na fato de que sempre que duas strings são concatenadas é então produzida uma terceira string. 1 2 3 String nome = &quot;Murilo &quot;; String sobrenome = &quot;Costa&quot;; nome = nome + sobrenome; Internamente aqui foram construídos três espaços de memória, o primeiro para representar a string &quot;Murilo &quot;, que foi atribuída a variável nome, o segundo para representar a string &quot;Costa&quot;, atribuída a variável sobrenome e então foi criado o último espaço de memória para armazenar os dois valores juntos, reatribuindo o novo valor na variável nome. Existem outras coisas importantes ao se falar sobre strings em Java, como o fato delas serem UTF-16, o mecanismo de internalização que otimiza drasticamente o reúso de strings, mas esses assuntos não vem ao caso de hoje. O problema da concatenção O grande vilão da concatenação de strings aqui está justamente no fato de strings serem imutáveis, o que acaba indiretamente gerando um processo duplicado a cada concatenação realizada. Como falei anteriormente, a concatenação de duas strings sempre produz uma terceira string, que é a junção das duas, e nessa junção basicamente se cria um novo vetor de caracteres com tamanho suficiente para as duas strings e se copia o valor das duas caractere a caractere para a nova string. O código executado é semelhante ao código abaixo. 1 2 3 4 5 6 7 8 9 10 11 12 13 public static String concatenate(String s1, String s2) { char[] result = new char[s1.length + s2.length]; int pos = 0; for (int i = 0; i &lt; s1.length; i++) { result[pos++] = s1.chartAt(i); } for (int i = 0; i &lt; s2.length; i++) { result[pos++] = s2.chartAt(i); } return new String(result); } Por esse código percebemos que sempre vamos ter que percorrer as duas strings que são concatenadas por inteiro, e se verificarmos o código de concatenação utilizado nos testes anteriores vamos ver que esse processo se repete utilizando sempre o resultado da última concatenação, o que implica em novamente sempre percorrer a mesma string por inteiro em cada concatenação. Para facilitar vamos reescrever o código do teste realizando a concatenação a partir do código acima. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public static String generateParagraphsTextWithStringConcat(int paragraphCount) { String text = &quot;&quot;; for (int i = 0; i &lt; paragraphCount; i++) { String paragraph = LoremIpsum.random().getText(); //novo parágrafo char[] newText = new char[text.length + paragraph.length]; int pos = 0; for (int i = 0; i &lt; text.length; i++) { //percore toda a string text novamente a cada concatenação result[pos++] = text.chartAt(i); } for (int i = 0; i &lt; paragraph.length; i++) { result[pos++] = paragraph.chartAt(i); } text = new String(newText); } return text; } Como pode ser visto no código anterior, para cada novo parágrafo adicionado o processo terá que percorrer toda a string text novamente, e é exatamente nesse ponto que a lentidão ocorre, pois quanto maior for a string text mais tempo essa cópia irá levar. Agora ficou mais fácil de entender o que ocorre internamente, não é mesmo? E quando temos um processo desse com instruções de loop (for) aninhadas, ou seja uma dentro da outra, processando o mesmo valor, temos um algoritmo de ordem Big O(n²), que é uma execução lenta comparada a outras performances. E por que isso não ocorre no StringBuilder? O StringBuilder trabalha de uma forma diferente, onde ele armazena uma espécie de lista strings que não são concatenadas durante a adição, sendo que isso ocorre somente ao chamar algum método que utilize seu valor, como é o caso do toString(). E é por isso que esse problema de performance não ocorre, pois cada inserção no StringBuilder não necessita percorrer todas as outras strings. A implementação por baixo dos panos com o StringBuilder seria mais ou menos assim. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public static String generateParagraphsTextWithStringBuilder(int paragraphCount) { var list = new LinkedList&lt;String&gt;(); var size = 0; for (int i = 0; i &lt; paragraphCount; i++) { String paragraph = LoremIpsum.random().getText(); //novo parágrafo size += paragraph.length; list.add(paragraph); } char[] text = new char[size]; var pos = 0; for (String s : list) { for (int i = 0; i &lt; s.length; i++) { //só concatena no final text[pos++] = s.chartAt(i); } } return new String(text); } Podemos perceber que nessa implementação não precisamos percorrer toda a string a cada novo parágrafo adicionado, onde a criação da nova string só ocorre no final juntando todas as strings adicionadas na lista, o que configura um algoritmo de ordem Big O(n), muito mais performático que o anterior. Obs: Existe uma explicação matemática mais precisa para configurar a ordem dos algoritmos citados acima, porém são explicações que envolvem teorias matemáticas que eu não quero trazer para cá, então caso você queira entender um pouco melhor isso, é possível encontrar essas explicações em buscas na internet, como essa aqui. E é por isso que, pelo menos em Java, sempre devemos dar preferência ao StringBuilder para concatenar strings ao invés da concatenação tradicional. Agora fica uma última pergunta: Se esse problema ocorre justamente pelo fato de strings serem imutáveis, por que ela são assim? Isso já é assunto para outro post :). Bônus: StringBuilder x StringBuffer em Java Em Java, além do StringBuilder existe também uma outra classe chamada StringBuffer para realizar concatenações de strings de forma mais performática, onde as duas funcionam basicamente da mesma forma. A maior diferença entre elas é que o StringBuffer é mais antigo e ele possui uma serie de locks para uso com processo multi-thread, onde seu uso é desaconselhado em casos single-thread. E é exatamente por essa característica que não é aconselhável utilizar o StringBuffer em processos que não tenham concorrência, pois esses locks podem prejudicar um pouco o desempenho do processo. Vamos ver as implementações usando cada um e seus testes para compararmos os resultados. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public static String generateParagraphsTextWithStringBuilder(int paragraphCount) { var text = new StringBuilder(); for (int i = 0; i &lt; paragraphCount; i++) { text.append(LoremIpsum.random().getText()); } return text.toString(); } public static String generateParagraphsTextWithStringBuffer(int paragraphCount) { var text = new StringBuffer(); for (int i = 0; i &lt; paragraphCount; i++) { text.append(LoremIpsum.random().getText()); } return text.toString(); } 1 2 3 4 5 6 7 8 9 10 11 @Test public void dezMilParagrafosDeTextoComStringBuilder() { var text = TextGenerator.generateParagraphsTextWithStringBuilder(10000); assertEquals(10000, text.chars().filter(ch -&gt; ch == &#39;\n&#39;).count()); } @Test public void dezMilParagrafosDeTextoComStringBuffer() { var text = TextGenerator.generateParagraphsTextWithStringBuffer(10000); assertEquals(10000, text.chars().filter(ch -&gt; ch == &#39;\n&#39;).count()); } Como é possível ver, a diferença no tempo de execução é pouca, mas ela ainda existe, e dependendo da complexidade do seu código isso pode se tornar um problema. E é isso aí pessoal, até a próxima. Ah, os códigos podem ser obtidos aqui." /><meta property="og:description" content="Eu acredito que a maioria das pessoas com alguma vivência na programação e que usa ou já usou Java, com certeza já ouviu falar que devemos evitar o uso de concatenação de strings na linguagem e devemos usar formas melhores como o uso do StringBuilder para casos em que será necessário concatenar grandes partes de texto, mas já parou alguma vez para entender o porquê disso? Esse é um problema que está ligado diretamente a análise de algoritmos e suas ordens, o famoso Big O, e vamos entender um pouco sobre isso no post de hoje. Vou usar o Java aqui nesse exemplo, porém o problema também existe em outras linguagens, onde cada uma provê sua própria solução. Vamos ao teste Apesar de já ter ouvido sobre essa questão diversas vezes, será que ela realmente é válida? Será que faz alguma diferença mesmo usar StringBuilder no lugar de concatenação de strings? Vamos então fazer alguns testes para verificar esse comportamento. Para testar vamos fazer um gerador de textos Lorem Ipsum aleatório, que irá gerar textos com uma quantidade definida de parágrafos, onde vamos comparar os tempos de execução em minha máquina, um i5 1.3GHz, 4GB de RAM e 128 SSD. Primeiramente vamos definir uma classe de constantes com os parágrafos Lorem Ipsum. 1 2 3 4 5 6 7 8 9 public class LoremIpsumText { public static String LOREM_TEXT_01 = &quot;Lorem ipsum dolor sit amet, consectetur ...\n&quot;; public static String LOREM_TEXT_02 = &quot;Donec a rutrum velit, eu sodales libero ...\n&quot;; public static String LOREM_TEXT_03 = &quot;Duis fringilla porttitor elit, ac conse ...\n&quot;; public static String LOREM_TEXT_04 = &quot;Fusce a euismod ante, ullamcorper variu ...\n&quot;; public static String LOREM_TEXT_05 = &quot;Lorem ipsum dolor sit amet, consectetur ...\n&quot;; } Os textos foram cortados aqui no post para não ficar muito grande. Repare que no final de cada texto existe uma quebra de linha representada por \n. A geração de parágrafos aleatórios será feita diretamente em uma enum representando os parágrafos disponíveis. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public enum LoremIpsum { LOREM_01(LoremIpsumText.LOREM_TEXT_01), LOREM_02(LoremIpsumText.LOREM_TEXT_02), LOREM_03(LoremIpsumText.LOREM_TEXT_03), LOREM_04(LoremIpsumText.LOREM_TEXT_04), LOREM_05(LoremIpsumText.LOREM_TEXT_05); private String text; private LoremIpsum(String text) { this.text = text; } public String getText() { return text; } public static LoremIpsum random() { var index = new Random().ints(0, values().length - 1) .findFirst() .getAsInt(); return values()[index]; } } Como pode ser visto na enum, cada opção mapeia para um texto diferente e o método random() traz um texto de forma aleatória. Isso nos ajuda a ter uma diversidade melhor no processo, garantindo que não ocorra nenhum vício por parte de execução do software, como cache de JVM por exemplo. Afim de termos certeza que essa geração é rápida o suficiente e não vai afetar os testes, vamos criar um teste unitário para geração e verificar o tempo decorrido. O teste unitário consistirá em obter um texto de forma aleatória e verificar se ele está de acordo com os textos disponíveis. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class LoremIpsumTest { @Test public void loremIpsumAleatorio() { var lorems = Arrays.asList( LoremIpsum.LOREM_01, LoremIpsum.LOREM_02, LoremIpsum.LOREM_03, LoremIpsum.LOREM_04, LoremIpsum.LOREM_05 ); var lorem = LoremIpsum.random(); assertTrue(lorems.contains(lorem)); } } Com esse resultado podemos ver que essa geração é extremamente rápida. Agora vamos então criar a classe que irá gerar os textos, usando concatenação de strings ou StringBuilder. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class TextGenerator { public static String generateParagraphsTextWithStringConcat(int paragraphCount) { String text = &quot;&quot;; for (int i = 0; i &lt; paragraphCount; i++) { text += LoremIpsum.random().getText(); } return text; } public static String generateParagraphsTextWithStringBuilder(int paragraphCount) { var text = new StringBuilder(); for (int i = 0; i &lt; paragraphCount; i++) { text.append(LoremIpsum.random().getText()); } return text.toString(); } } A classe acima possui somente dois métodos estáticos que fazem a mesma coisa: receber uma quantidade de parágrafos por parâmetro e então gerar textos aleatórios usando junções de parágrafos providos por LoremIpsum.random(), de acordo com a quantidade de parágrafos definida. E agora vamos aos teste finais. Os testes consistirão também de testes unitários, que irão gerar o texto com uma quantidade definida de parágrafos e depois testar a quantidade de quebras de linha no texto. Inicialmente vamos usar uma quantidade de cem parágrafos e ver o resultado. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class TextGeneratorTest { @Test public void cemParagrafosDeTextoComStringConcat() { var text = TextGenerator.generateParagraphsTextWithStringConcat(100); assertEquals(100, text.chars().filter(ch -&gt; ch == &#39;\n&#39;).count()); } @Test public void cemParagrafosDeTextoComStringBuilder() { var text = TextGenerator.generateParagraphsTextWithStringBuilder(100); assertEquals(100, text.chars().filter(ch -&gt; ch == &#39;\n&#39;).count()); } } Podemos ver na imagem que o tempo de execução foi o mesmo para as duas abordagens: 0,000 segundos. Será que então realmente não têm diferença entre elas? Vamos utilizar mil parágrafos no próximo teste. 1 2 3 4 5 6 7 8 9 10 11 12 13 public class TextGeneratorTest { @Test public void milParagrafosDeTextoComStringConcat() { var text = TextGenerator.generateParagraphsTextWithStringConcat(1000); assertEquals(1000, text.chars().filter(ch -&gt; ch == &#39;\n&#39;).count()); } @Test public void milParagrafosDeTextoComStringBuilder() { var text = TextGenerator.generateParagraphsTextWithStringBuilder(1000); assertEquals(1000, text.chars().filter(ch -&gt; ch == &#39;\n&#39;).count()); } } Opa! Agora parece que já temos uma pequena diferença, onde a abordagem com o StringBuilder continua com 0,000 segundos, mas a concatenação já está levando 419 milissegundos (0,419 segundos) de execução. Porém isso ainda não é algo que realmente faça tanta diferença assim para que seja uma recomendação levada a sério. Vamos então subir um pouco mais a quantidade de parágrafos no nosso teste final: dez mil. 1 2 3 4 5 6 7 8 9 10 11 12 13 public class TextGeneratorTest { @Test public void dezMilParagrafosDeTextoComStringConcat() { var text = TextGenerator.generateParagraphsTextWithStringConcat(10000); assertEquals(10000, text.chars().filter(ch -&gt; ch == &#39;\n&#39;).count()); } @Test public void dezMilParagrafosDeTextoComStringBuilder() { var text = TextGenerator.generateParagraphsTextWithStringBuilder(10000); assertEquals(10000, text.chars().filter(ch -&gt; ch == &#39;\n&#39;).count()); } } E então finalmente temos nossa grande diferença. Usando o StringBuilder temos um tempo de execução de 0,007 segundos (7 milissegundos), enquanto que a concatenação levou longos 26,220 segundos, um tempo imensamente maior que o da primeira abordagem, o que comprova que realmente o StringBuilder é a melhor alternativa principalmente para textos longos. Mas por quê isso acontece? Entendendo strings Antes de falar sobre o problema vamos mostrar algumas coisas sobre as strings e como elas funcionam. A maioria das linguagens (principalmente as compiladas) possuem diferentes tipos de atributos, geralmente chamados de tipos de variáveis, onde eles são separados em primitivos e complexos. Os primitivos são os tipos mais básicos das linguagens, no caso do Java eles são a menor representação que um tipo pode ter, que são os tipos int, short, long, byte, float, double, boolean, char e etc, e os tipos complexos são definições criadas utilizando a linguagem e que agrupam e/ou manusei am esses tipos primitivos, onde em Java as classes, enums e interfaces são utilizadas para esse propósito. Para exemplificar podemos ter os atributos primitivos int codigo e double valor para representar o código e valor de um produto, e podemos então criar um tipo complexo que é uma classe Produto contendo esses atributos primitivos, o que nos permite manusear os tipos primitivos de forma agrupada no tipo complexo. 1 2 3 4 5 6 7 8 public class Produto { int codigo; double valor; } var produto = new Produto(); produto.codigo = 1; produto.valor = 10.0; As strings em Java funcionam dessa mesma forma, onde uma String é uma classe que representa um conjunto de letras, armazenadas no formato de um vetor de caracteres, ou seja um char[] texto. Basicamente quando uma String é declarada, internamente é criado um vetor contendo os caracteres do texto e esse vetor nunca muda, pois as strings são imutáveis, ou seja não podem ser modificadas, e isso implica na fato de que sempre que duas strings são concatenadas é então produzida uma terceira string. 1 2 3 String nome = &quot;Murilo &quot;; String sobrenome = &quot;Costa&quot;; nome = nome + sobrenome; Internamente aqui foram construídos três espaços de memória, o primeiro para representar a string &quot;Murilo &quot;, que foi atribuída a variável nome, o segundo para representar a string &quot;Costa&quot;, atribuída a variável sobrenome e então foi criado o último espaço de memória para armazenar os dois valores juntos, reatribuindo o novo valor na variável nome. Existem outras coisas importantes ao se falar sobre strings em Java, como o fato delas serem UTF-16, o mecanismo de internalização que otimiza drasticamente o reúso de strings, mas esses assuntos não vem ao caso de hoje. O problema da concatenção O grande vilão da concatenação de strings aqui está justamente no fato de strings serem imutáveis, o que acaba indiretamente gerando um processo duplicado a cada concatenação realizada. Como falei anteriormente, a concatenação de duas strings sempre produz uma terceira string, que é a junção das duas, e nessa junção basicamente se cria um novo vetor de caracteres com tamanho suficiente para as duas strings e se copia o valor das duas caractere a caractere para a nova string. O código executado é semelhante ao código abaixo. 1 2 3 4 5 6 7 8 9 10 11 12 13 public static String concatenate(String s1, String s2) { char[] result = new char[s1.length + s2.length]; int pos = 0; for (int i = 0; i &lt; s1.length; i++) { result[pos++] = s1.chartAt(i); } for (int i = 0; i &lt; s2.length; i++) { result[pos++] = s2.chartAt(i); } return new String(result); } Por esse código percebemos que sempre vamos ter que percorrer as duas strings que são concatenadas por inteiro, e se verificarmos o código de concatenação utilizado nos testes anteriores vamos ver que esse processo se repete utilizando sempre o resultado da última concatenação, o que implica em novamente sempre percorrer a mesma string por inteiro em cada concatenação. Para facilitar vamos reescrever o código do teste realizando a concatenação a partir do código acima. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public static String generateParagraphsTextWithStringConcat(int paragraphCount) { String text = &quot;&quot;; for (int i = 0; i &lt; paragraphCount; i++) { String paragraph = LoremIpsum.random().getText(); //novo parágrafo char[] newText = new char[text.length + paragraph.length]; int pos = 0; for (int i = 0; i &lt; text.length; i++) { //percore toda a string text novamente a cada concatenação result[pos++] = text.chartAt(i); } for (int i = 0; i &lt; paragraph.length; i++) { result[pos++] = paragraph.chartAt(i); } text = new String(newText); } return text; } Como pode ser visto no código anterior, para cada novo parágrafo adicionado o processo terá que percorrer toda a string text novamente, e é exatamente nesse ponto que a lentidão ocorre, pois quanto maior for a string text mais tempo essa cópia irá levar. Agora ficou mais fácil de entender o que ocorre internamente, não é mesmo? E quando temos um processo desse com instruções de loop (for) aninhadas, ou seja uma dentro da outra, processando o mesmo valor, temos um algoritmo de ordem Big O(n²), que é uma execução lenta comparada a outras performances. E por que isso não ocorre no StringBuilder? O StringBuilder trabalha de uma forma diferente, onde ele armazena uma espécie de lista strings que não são concatenadas durante a adição, sendo que isso ocorre somente ao chamar algum método que utilize seu valor, como é o caso do toString(). E é por isso que esse problema de performance não ocorre, pois cada inserção no StringBuilder não necessita percorrer todas as outras strings. A implementação por baixo dos panos com o StringBuilder seria mais ou menos assim. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public static String generateParagraphsTextWithStringBuilder(int paragraphCount) { var list = new LinkedList&lt;String&gt;(); var size = 0; for (int i = 0; i &lt; paragraphCount; i++) { String paragraph = LoremIpsum.random().getText(); //novo parágrafo size += paragraph.length; list.add(paragraph); } char[] text = new char[size]; var pos = 0; for (String s : list) { for (int i = 0; i &lt; s.length; i++) { //só concatena no final text[pos++] = s.chartAt(i); } } return new String(text); } Podemos perceber que nessa implementação não precisamos percorrer toda a string a cada novo parágrafo adicionado, onde a criação da nova string só ocorre no final juntando todas as strings adicionadas na lista, o que configura um algoritmo de ordem Big O(n), muito mais performático que o anterior. Obs: Existe uma explicação matemática mais precisa para configurar a ordem dos algoritmos citados acima, porém são explicações que envolvem teorias matemáticas que eu não quero trazer para cá, então caso você queira entender um pouco melhor isso, é possível encontrar essas explicações em buscas na internet, como essa aqui. E é por isso que, pelo menos em Java, sempre devemos dar preferência ao StringBuilder para concatenar strings ao invés da concatenação tradicional. Agora fica uma última pergunta: Se esse problema ocorre justamente pelo fato de strings serem imutáveis, por que ela são assim? Isso já é assunto para outro post :). Bônus: StringBuilder x StringBuffer em Java Em Java, além do StringBuilder existe também uma outra classe chamada StringBuffer para realizar concatenações de strings de forma mais performática, onde as duas funcionam basicamente da mesma forma. A maior diferença entre elas é que o StringBuffer é mais antigo e ele possui uma serie de locks para uso com processo multi-thread, onde seu uso é desaconselhado em casos single-thread. E é exatamente por essa característica que não é aconselhável utilizar o StringBuffer em processos que não tenham concorrência, pois esses locks podem prejudicar um pouco o desempenho do processo. Vamos ver as implementações usando cada um e seus testes para compararmos os resultados. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public static String generateParagraphsTextWithStringBuilder(int paragraphCount) { var text = new StringBuilder(); for (int i = 0; i &lt; paragraphCount; i++) { text.append(LoremIpsum.random().getText()); } return text.toString(); } public static String generateParagraphsTextWithStringBuffer(int paragraphCount) { var text = new StringBuffer(); for (int i = 0; i &lt; paragraphCount; i++) { text.append(LoremIpsum.random().getText()); } return text.toString(); } 1 2 3 4 5 6 7 8 9 10 11 @Test public void dezMilParagrafosDeTextoComStringBuilder() { var text = TextGenerator.generateParagraphsTextWithStringBuilder(10000); assertEquals(10000, text.chars().filter(ch -&gt; ch == &#39;\n&#39;).count()); } @Test public void dezMilParagrafosDeTextoComStringBuffer() { var text = TextGenerator.generateParagraphsTextWithStringBuffer(10000); assertEquals(10000, text.chars().filter(ch -&gt; ch == &#39;\n&#39;).count()); } Como é possível ver, a diferença no tempo de execução é pouca, mas ela ainda existe, e dependendo da complexidade do seu código isso pode se tornar um problema. E é isso aí pessoal, até a próxima. Ah, os códigos podem ser obtidos aqui." /><link rel="canonical" href="https://murilo.tech/posts/concatenacao-de-strings-e-performance/" /><meta property="og:url" content="https://murilo.tech/posts/concatenacao-de-strings-e-performance/" /><meta property="og:site_name" content="murilo.tech" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-12-20T12:00:00-03:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Concatenação de strings e performance" /><meta name="twitter:site" content="@muriloramosdc" /><meta name="twitter:creator" content="@Murilo Costa" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"Eu acredito que a maioria das pessoas com alguma vivência na programação e que usa ou já usou Java, com certeza já ouviu falar que devemos evitar o uso de concatenação de strings na linguagem e devemos usar formas melhores como o uso do StringBuilder para casos em que será necessário concatenar grandes partes de texto, mas já parou alguma vez para entender o porquê disso? Esse é um problema que está ligado diretamente a análise de algoritmos e suas ordens, o famoso Big O, e vamos entender um pouco sobre isso no post de hoje. Vou usar o Java aqui nesse exemplo, porém o problema também existe em outras linguagens, onde cada uma provê sua própria solução. Vamos ao teste Apesar de já ter ouvido sobre essa questão diversas vezes, será que ela realmente é válida? Será que faz alguma diferença mesmo usar StringBuilder no lugar de concatenação de strings? Vamos então fazer alguns testes para verificar esse comportamento. Para testar vamos fazer um gerador de textos Lorem Ipsum aleatório, que irá gerar textos com uma quantidade definida de parágrafos, onde vamos comparar os tempos de execução em minha máquina, um i5 1.3GHz, 4GB de RAM e 128 SSD. Primeiramente vamos definir uma classe de constantes com os parágrafos Lorem Ipsum. 1 2 3 4 5 6 7 8 9 public class LoremIpsumText { public static String LOREM_TEXT_01 = &quot;Lorem ipsum dolor sit amet, consectetur ...\\n&quot;; public static String LOREM_TEXT_02 = &quot;Donec a rutrum velit, eu sodales libero ...\\n&quot;; public static String LOREM_TEXT_03 = &quot;Duis fringilla porttitor elit, ac conse ...\\n&quot;; public static String LOREM_TEXT_04 = &quot;Fusce a euismod ante, ullamcorper variu ...\\n&quot;; public static String LOREM_TEXT_05 = &quot;Lorem ipsum dolor sit amet, consectetur ...\\n&quot;; } Os textos foram cortados aqui no post para não ficar muito grande. Repare que no final de cada texto existe uma quebra de linha representada por \\n. A geração de parágrafos aleatórios será feita diretamente em uma enum representando os parágrafos disponíveis. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public enum LoremIpsum { LOREM_01(LoremIpsumText.LOREM_TEXT_01), LOREM_02(LoremIpsumText.LOREM_TEXT_02), LOREM_03(LoremIpsumText.LOREM_TEXT_03), LOREM_04(LoremIpsumText.LOREM_TEXT_04), LOREM_05(LoremIpsumText.LOREM_TEXT_05); private String text; private LoremIpsum(String text) { this.text = text; } public String getText() { return text; } public static LoremIpsum random() { var index = new Random().ints(0, values().length - 1) .findFirst() .getAsInt(); return values()[index]; } } Como pode ser visto na enum, cada opção mapeia para um texto diferente e o método random() traz um texto de forma aleatória. Isso nos ajuda a ter uma diversidade melhor no processo, garantindo que não ocorra nenhum vício por parte de execução do software, como cache de JVM por exemplo. Afim de termos certeza que essa geração é rápida o suficiente e não vai afetar os testes, vamos criar um teste unitário para geração e verificar o tempo decorrido. O teste unitário consistirá em obter um texto de forma aleatória e verificar se ele está de acordo com os textos disponíveis. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class LoremIpsumTest { @Test public void loremIpsumAleatorio() { var lorems = Arrays.asList( LoremIpsum.LOREM_01, LoremIpsum.LOREM_02, LoremIpsum.LOREM_03, LoremIpsum.LOREM_04, LoremIpsum.LOREM_05 ); var lorem = LoremIpsum.random(); assertTrue(lorems.contains(lorem)); } } Com esse resultado podemos ver que essa geração é extremamente rápida. Agora vamos então criar a classe que irá gerar os textos, usando concatenação de strings ou StringBuilder. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class TextGenerator { public static String generateParagraphsTextWithStringConcat(int paragraphCount) { String text = &quot;&quot;; for (int i = 0; i &lt; paragraphCount; i++) { text += LoremIpsum.random().getText(); } return text; } public static String generateParagraphsTextWithStringBuilder(int paragraphCount) { var text = new StringBuilder(); for (int i = 0; i &lt; paragraphCount; i++) { text.append(LoremIpsum.random().getText()); } return text.toString(); } } A classe acima possui somente dois métodos estáticos que fazem a mesma coisa: receber uma quantidade de parágrafos por parâmetro e então gerar textos aleatórios usando junções de parágrafos providos por LoremIpsum.random(), de acordo com a quantidade de parágrafos definida. E agora vamos aos teste finais. Os testes consistirão também de testes unitários, que irão gerar o texto com uma quantidade definida de parágrafos e depois testar a quantidade de quebras de linha no texto. Inicialmente vamos usar uma quantidade de cem parágrafos e ver o resultado. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class TextGeneratorTest { @Test public void cemParagrafosDeTextoComStringConcat() { var text = TextGenerator.generateParagraphsTextWithStringConcat(100); assertEquals(100, text.chars().filter(ch -&gt; ch == &#39;\\n&#39;).count()); } @Test public void cemParagrafosDeTextoComStringBuilder() { var text = TextGenerator.generateParagraphsTextWithStringBuilder(100); assertEquals(100, text.chars().filter(ch -&gt; ch == &#39;\\n&#39;).count()); } } Podemos ver na imagem que o tempo de execução foi o mesmo para as duas abordagens: 0,000 segundos. Será que então realmente não têm diferença entre elas? Vamos utilizar mil parágrafos no próximo teste. 1 2 3 4 5 6 7 8 9 10 11 12 13 public class TextGeneratorTest { @Test public void milParagrafosDeTextoComStringConcat() { var text = TextGenerator.generateParagraphsTextWithStringConcat(1000); assertEquals(1000, text.chars().filter(ch -&gt; ch == &#39;\\n&#39;).count()); } @Test public void milParagrafosDeTextoComStringBuilder() { var text = TextGenerator.generateParagraphsTextWithStringBuilder(1000); assertEquals(1000, text.chars().filter(ch -&gt; ch == &#39;\\n&#39;).count()); } } Opa! Agora parece que já temos uma pequena diferença, onde a abordagem com o StringBuilder continua com 0,000 segundos, mas a concatenação já está levando 419 milissegundos (0,419 segundos) de execução. Porém isso ainda não é algo que realmente faça tanta diferença assim para que seja uma recomendação levada a sério. Vamos então subir um pouco mais a quantidade de parágrafos no nosso teste final: dez mil. 1 2 3 4 5 6 7 8 9 10 11 12 13 public class TextGeneratorTest { @Test public void dezMilParagrafosDeTextoComStringConcat() { var text = TextGenerator.generateParagraphsTextWithStringConcat(10000); assertEquals(10000, text.chars().filter(ch -&gt; ch == &#39;\\n&#39;).count()); } @Test public void dezMilParagrafosDeTextoComStringBuilder() { var text = TextGenerator.generateParagraphsTextWithStringBuilder(10000); assertEquals(10000, text.chars().filter(ch -&gt; ch == &#39;\\n&#39;).count()); } } E então finalmente temos nossa grande diferença. Usando o StringBuilder temos um tempo de execução de 0,007 segundos (7 milissegundos), enquanto que a concatenação levou longos 26,220 segundos, um tempo imensamente maior que o da primeira abordagem, o que comprova que realmente o StringBuilder é a melhor alternativa principalmente para textos longos. Mas por quê isso acontece? Entendendo strings Antes de falar sobre o problema vamos mostrar algumas coisas sobre as strings e como elas funcionam. A maioria das linguagens (principalmente as compiladas) possuem diferentes tipos de atributos, geralmente chamados de tipos de variáveis, onde eles são separados em primitivos e complexos. Os primitivos são os tipos mais básicos das linguagens, no caso do Java eles são a menor representação que um tipo pode ter, que são os tipos int, short, long, byte, float, double, boolean, char e etc, e os tipos complexos são definições criadas utilizando a linguagem e que agrupam e/ou manusei am esses tipos primitivos, onde em Java as classes, enums e interfaces são utilizadas para esse propósito. Para exemplificar podemos ter os atributos primitivos int codigo e double valor para representar o código e valor de um produto, e podemos então criar um tipo complexo que é uma classe Produto contendo esses atributos primitivos, o que nos permite manusear os tipos primitivos de forma agrupada no tipo complexo. 1 2 3 4 5 6 7 8 public class Produto { int codigo; double valor; } var produto = new Produto(); produto.codigo = 1; produto.valor = 10.0; As strings em Java funcionam dessa mesma forma, onde uma String é uma classe que representa um conjunto de letras, armazenadas no formato de um vetor de caracteres, ou seja um char[] texto. Basicamente quando uma String é declarada, internamente é criado um vetor contendo os caracteres do texto e esse vetor nunca muda, pois as strings são imutáveis, ou seja não podem ser modificadas, e isso implica na fato de que sempre que duas strings são concatenadas é então produzida uma terceira string. 1 2 3 String nome = &quot;Murilo &quot;; String sobrenome = &quot;Costa&quot;; nome = nome + sobrenome; Internamente aqui foram construídos três espaços de memória, o primeiro para representar a string &quot;Murilo &quot;, que foi atribuída a variável nome, o segundo para representar a string &quot;Costa&quot;, atribuída a variável sobrenome e então foi criado o último espaço de memória para armazenar os dois valores juntos, reatribuindo o novo valor na variável nome. Existem outras coisas importantes ao se falar sobre strings em Java, como o fato delas serem UTF-16, o mecanismo de internalização que otimiza drasticamente o reúso de strings, mas esses assuntos não vem ao caso de hoje. O problema da concatenção O grande vilão da concatenação de strings aqui está justamente no fato de strings serem imutáveis, o que acaba indiretamente gerando um processo duplicado a cada concatenação realizada. Como falei anteriormente, a concatenação de duas strings sempre produz uma terceira string, que é a junção das duas, e nessa junção basicamente se cria um novo vetor de caracteres com tamanho suficiente para as duas strings e se copia o valor das duas caractere a caractere para a nova string. O código executado é semelhante ao código abaixo. 1 2 3 4 5 6 7 8 9 10 11 12 13 public static String concatenate(String s1, String s2) { char[] result = new char[s1.length + s2.length]; int pos = 0; for (int i = 0; i &lt; s1.length; i++) { result[pos++] = s1.chartAt(i); } for (int i = 0; i &lt; s2.length; i++) { result[pos++] = s2.chartAt(i); } return new String(result); } Por esse código percebemos que sempre vamos ter que percorrer as duas strings que são concatenadas por inteiro, e se verificarmos o código de concatenação utilizado nos testes anteriores vamos ver que esse processo se repete utilizando sempre o resultado da última concatenação, o que implica em novamente sempre percorrer a mesma string por inteiro em cada concatenação. Para facilitar vamos reescrever o código do teste realizando a concatenação a partir do código acima. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public static String generateParagraphsTextWithStringConcat(int paragraphCount) { String text = &quot;&quot;; for (int i = 0; i &lt; paragraphCount; i++) { String paragraph = LoremIpsum.random().getText(); //novo parágrafo char[] newText = new char[text.length + paragraph.length]; int pos = 0; for (int i = 0; i &lt; text.length; i++) { //percore toda a string text novamente a cada concatenação result[pos++] = text.chartAt(i); } for (int i = 0; i &lt; paragraph.length; i++) { result[pos++] = paragraph.chartAt(i); } text = new String(newText); } return text; } Como pode ser visto no código anterior, para cada novo parágrafo adicionado o processo terá que percorrer toda a string text novamente, e é exatamente nesse ponto que a lentidão ocorre, pois quanto maior for a string text mais tempo essa cópia irá levar. Agora ficou mais fácil de entender o que ocorre internamente, não é mesmo? E quando temos um processo desse com instruções de loop (for) aninhadas, ou seja uma dentro da outra, processando o mesmo valor, temos um algoritmo de ordem Big O(n²), que é uma execução lenta comparada a outras performances. E por que isso não ocorre no StringBuilder? O StringBuilder trabalha de uma forma diferente, onde ele armazena uma espécie de lista strings que não são concatenadas durante a adição, sendo que isso ocorre somente ao chamar algum método que utilize seu valor, como é o caso do toString(). E é por isso que esse problema de performance não ocorre, pois cada inserção no StringBuilder não necessita percorrer todas as outras strings. A implementação por baixo dos panos com o StringBuilder seria mais ou menos assim. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public static String generateParagraphsTextWithStringBuilder(int paragraphCount) { var list = new LinkedList&lt;String&gt;(); var size = 0; for (int i = 0; i &lt; paragraphCount; i++) { String paragraph = LoremIpsum.random().getText(); //novo parágrafo size += paragraph.length; list.add(paragraph); } char[] text = new char[size]; var pos = 0; for (String s : list) { for (int i = 0; i &lt; s.length; i++) { //só concatena no final text[pos++] = s.chartAt(i); } } return new String(text); } Podemos perceber que nessa implementação não precisamos percorrer toda a string a cada novo parágrafo adicionado, onde a criação da nova string só ocorre no final juntando todas as strings adicionadas na lista, o que configura um algoritmo de ordem Big O(n), muito mais performático que o anterior. Obs: Existe uma explicação matemática mais precisa para configurar a ordem dos algoritmos citados acima, porém são explicações que envolvem teorias matemáticas que eu não quero trazer para cá, então caso você queira entender um pouco melhor isso, é possível encontrar essas explicações em buscas na internet, como essa aqui. E é por isso que, pelo menos em Java, sempre devemos dar preferência ao StringBuilder para concatenar strings ao invés da concatenação tradicional. Agora fica uma última pergunta: Se esse problema ocorre justamente pelo fato de strings serem imutáveis, por que ela são assim? Isso já é assunto para outro post :). Bônus: StringBuilder x StringBuffer em Java Em Java, além do StringBuilder existe também uma outra classe chamada StringBuffer para realizar concatenações de strings de forma mais performática, onde as duas funcionam basicamente da mesma forma. A maior diferença entre elas é que o StringBuffer é mais antigo e ele possui uma serie de locks para uso com processo multi-thread, onde seu uso é desaconselhado em casos single-thread. E é exatamente por essa característica que não é aconselhável utilizar o StringBuffer em processos que não tenham concorrência, pois esses locks podem prejudicar um pouco o desempenho do processo. Vamos ver as implementações usando cada um e seus testes para compararmos os resultados. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public static String generateParagraphsTextWithStringBuilder(int paragraphCount) { var text = new StringBuilder(); for (int i = 0; i &lt; paragraphCount; i++) { text.append(LoremIpsum.random().getText()); } return text.toString(); } public static String generateParagraphsTextWithStringBuffer(int paragraphCount) { var text = new StringBuffer(); for (int i = 0; i &lt; paragraphCount; i++) { text.append(LoremIpsum.random().getText()); } return text.toString(); } 1 2 3 4 5 6 7 8 9 10 11 @Test public void dezMilParagrafosDeTextoComStringBuilder() { var text = TextGenerator.generateParagraphsTextWithStringBuilder(10000); assertEquals(10000, text.chars().filter(ch -&gt; ch == &#39;\\n&#39;).count()); } @Test public void dezMilParagrafosDeTextoComStringBuffer() { var text = TextGenerator.generateParagraphsTextWithStringBuffer(10000); assertEquals(10000, text.chars().filter(ch -&gt; ch == &#39;\\n&#39;).count()); } Como é possível ver, a diferença no tempo de execução é pouca, mas ela ainda existe, e dependendo da complexidade do seu código isso pode se tornar um problema. E é isso aí pessoal, até a próxima. Ah, os códigos podem ser obtidos aqui.","@type":"BlogPosting","url":"https://murilo.tech/posts/concatenacao-de-strings-e-performance/","headline":"Concatenação de strings e performance","datePublished":"2021-12-20T12:00:00-03:00","dateModified":"2021-12-20T12:00:00-03:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://murilo.tech/posts/concatenacao-de-strings-e-performance/"},"author":{"@type":"Person","name":"Murilo Costa"},"@context":"https://schema.org"}</script> <!-- The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps Generated by: https://www.favicon-generator.org/ v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT license --><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="preload" as="style" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"> <!-- CSS selector for site. Chirpy v2.3 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT Licensed --><link rel="preload" as="style" href="/assets/css/post.css"><link rel="stylesheet" href="/assets/css/post.css"><link rel="preload" as="style" href="/assets/css/lib/bootstrap-toc.min.css"><link rel="stylesheet" href="/assets/css/lib/bootstrap-toc.min.css" /><link rel="preload" as="script" href="https://cdn.jsdelivr.net/npm/jquery@3.4.1" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"> <script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4.0.0/dist/js/bootstrap.min.js" async></script> <!-- JS selector for site. Chirpy v2.3 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT Licensed --> <script src="/assets/js/post.min.js" async></script> <script src="/app.js" defer></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column"> <!-- The Side Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="nav-wrapper"><div id="profile-wrapper" class="d-flex flex-column"><div id="avatar" class="d-flex justify-content-center"> <a href="/" alt="avatar"> <img src="/assets/img/profile/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="profile-text mt-3"><div class="site-title"> <a href="/">murilo.tech</a></div><div class="site-subtitle font-italic">Posts sobre tecnologia, TI e desenvolvimento de software em geral.</div></div></div><ul class="nav flex-column"><li class="nav-item d-flex justify-content-center "> <a href="/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/categories/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIAS</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/tags/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/archives/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARQUIVO</span> </a></li><li class="nav-item d-flex justify-content-center "> <a href="/tabs/about/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>SOBRE</span> </a></li></ul></div><div class="sidebar-bottom d-flex flex-wrap justify-content-around mt-4"> <a href="https://github.com/murilo-ramos" target="_blank"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/muriloramosdc" target="_blank"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:window.open('mailto:' + ['murilo','murilo.tech'].join('@'))" > <i class="fas fa-envelope"></i> </a> <a href="https://www.linkedin.com/in/muriloramosduartecosta " target="_blank"> <i class="fab fa-linkedin"></i> </a></div></div><!-- The Top Bar v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Concatenação de strings e performance</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" placeholder="Buscar..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"> <!-- Refactor the HTML structure. --> <!-- Suroundding the markdown table with '<div class="table-wrapper">. and '</div>' --> <!-- Fixed kramdown code highlight rendering: https://github.com/penibelst/jekyll-compress-html/issues/101 https://github.com/penibelst/jekyll-compress-html/issues/71#issuecomment-188144901 --><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Concatenação de strings e performance</h1><div class="post-meta text-muted d-flex flex-column"><div> Posted <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Mon, Dec 20, 2021, 12:00 PM -0300" > Dec 20, 2021 <i class="unloaded">2021-12-20T12:00:00-03:00</i> </span> by <span class="author"> Murilo Costa </span></div></div><div class="post-content"><p style="text-align: justify;">Eu acredito que a maioria das pessoas com alguma vivência na programação e que usa ou já usou Java, com certeza já ouviu falar que devemos evitar o uso de concatenação de strings na linguagem e devemos usar formas melhores como o uso do <code class="language-plaintext highlighter-rouge">StringBuilder</code> para casos em que será necessário concatenar grandes partes de texto, mas já parou alguma vez para entender o porquê disso?</p><p style="text-align: justify;">Esse é um problema que está ligado diretamente a análise de algoritmos e suas ordens, o famoso <a href="https://medium.com/linkapi-solutions/o-que-%C3%A9-big-o-notation-32f171e4a045" target="_blank">Big O</a>, e vamos entender um pouco sobre isso no post de hoje.</p><p style="text-align: justify;">Vou usar o Java aqui nesse exemplo, porém o problema também existe em outras linguagens, onde cada uma provê sua própria solução.</p><h2 id="vamos-ao-teste">Vamos ao teste</h2><p style="text-align: justify;">Apesar de já ter ouvido sobre essa questão diversas vezes, será que ela realmente é válida? Será que faz alguma diferença mesmo usar <code class="language-plaintext highlighter-rouge">StringBuilder</code> no lugar de concatenação de strings?</p><p style="text-align: justify;">Vamos então fazer alguns testes para verificar esse comportamento.</p><p style="text-align: justify;">Para testar vamos fazer um gerador de textos <a href="https://pt.wikipedia.org/wiki/Lorem_ipsum" target="_blank">Lorem Ipsum</a> aleatório, que irá gerar textos com uma quantidade definida de parágrafos, onde vamos comparar os tempos de execução em minha máquina, um i5 1.3GHz, 4GB de RAM e 128 SSD.</p><p style="text-align: justify;">Primeiramente vamos definir uma classe de constantes com os parágrafos Lorem Ipsum.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LoremIpsumText</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="no">LOREM_TEXT_01</span> <span class="o">=</span> <span class="s">"Lorem ipsum dolor sit amet, consectetur ...\n"</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="no">LOREM_TEXT_02</span> <span class="o">=</span> <span class="s">"Donec a rutrum velit, eu sodales libero ...\n"</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="no">LOREM_TEXT_03</span> <span class="o">=</span> <span class="s">"Duis fringilla porttitor elit, ac conse ...\n"</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="no">LOREM_TEXT_04</span> <span class="o">=</span> <span class="s">"Fusce a euismod ante, ullamcorper variu ...\n"</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="no">LOREM_TEXT_05</span> <span class="o">=</span> <span class="s">"Lorem ipsum dolor sit amet, consectetur ...\n"</span><span class="o">;</span>

<span class="o">}</span>
</pre></table></code></div></div><p style="text-align: justify;">Os textos foram cortados aqui no post para não ficar muito grande. Repare que no final de cada texto existe uma quebra de linha representada por <code class="language-plaintext highlighter-rouge">\n</code>.</p><p style="text-align: justify;">A geração de parágrafos aleatórios será feita diretamente em uma <code class="language-plaintext highlighter-rouge">enum</code> representando os parágrafos disponíveis.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">enum</span> <span class="nc">LoremIpsum</span> <span class="o">{</span>
	
    <span class="no">LOREM_01</span><span class="o">(</span><span class="nc">LoremIpsumText</span><span class="o">.</span><span class="na">LOREM_TEXT_01</span><span class="o">),</span>
    <span class="no">LOREM_02</span><span class="o">(</span><span class="nc">LoremIpsumText</span><span class="o">.</span><span class="na">LOREM_TEXT_02</span><span class="o">),</span>
    <span class="no">LOREM_03</span><span class="o">(</span><span class="nc">LoremIpsumText</span><span class="o">.</span><span class="na">LOREM_TEXT_03</span><span class="o">),</span>
    <span class="no">LOREM_04</span><span class="o">(</span><span class="nc">LoremIpsumText</span><span class="o">.</span><span class="na">LOREM_TEXT_04</span><span class="o">),</span>
    <span class="no">LOREM_05</span><span class="o">(</span><span class="nc">LoremIpsumText</span><span class="o">.</span><span class="na">LOREM_TEXT_05</span><span class="o">);</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">text</span><span class="o">;</span>
	
    <span class="kd">private</span> <span class="nf">LoremIpsum</span><span class="o">(</span><span class="nc">String</span> <span class="n">text</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">text</span> <span class="o">=</span> <span class="n">text</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getText</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">text</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">LoremIpsum</span> <span class="nf">random</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">var</span> <span class="n">index</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">().</span><span class="na">ints</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">values</span><span class="o">().</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
            <span class="o">.</span><span class="na">findFirst</span><span class="o">()</span>
            <span class="o">.</span><span class="na">getAsInt</span><span class="o">();</span>

        <span class="k">return</span> <span class="nf">values</span><span class="o">()[</span><span class="n">index</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p style="text-align: justify;">Como pode ser visto na <code class="language-plaintext highlighter-rouge">enum</code>, cada opção mapeia para um texto diferente e o método <code class="language-plaintext highlighter-rouge">random()</code> traz um texto de forma aleatória. Isso nos ajuda a ter uma diversidade melhor no processo, garantindo que não ocorra nenhum vício por parte de execução do software, como cache de <a href="https://www.devmedia.com.br/introducao-ao-java-virtual-machine-jvm/27624" target="_blank">JVM</a> por exemplo.</p><p style="text-align: justify;">Afim de termos certeza que essa geração é rápida o suficiente e não vai afetar os testes, vamos criar um teste unitário para geração e verificar o tempo decorrido. O teste unitário consistirá em obter um texto de forma aleatória e verificar se ele está de acordo com os textos disponíveis.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LoremIpsumTest</span> <span class="o">{</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">loremIpsumAleatorio</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">var</span> <span class="n">lorems</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span>
            <span class="nc">LoremIpsum</span><span class="o">.</span><span class="na">LOREM_01</span><span class="o">,</span>
            <span class="nc">LoremIpsum</span><span class="o">.</span><span class="na">LOREM_02</span><span class="o">,</span>
            <span class="nc">LoremIpsum</span><span class="o">.</span><span class="na">LOREM_03</span><span class="o">,</span>
            <span class="nc">LoremIpsum</span><span class="o">.</span><span class="na">LOREM_04</span><span class="o">,</span>
            <span class="nc">LoremIpsum</span><span class="o">.</span><span class="na">LOREM_05</span>
        <span class="o">);</span>

        <span class="kt">var</span> <span class="n">lorem</span> <span class="o">=</span> <span class="nc">LoremIpsum</span><span class="o">.</span><span class="na">random</span><span class="o">();</span>

        <span class="n">assertTrue</span><span class="o">(</span><span class="n">lorems</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">lorem</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/concatenacao-de-strings-e-performance/unit-test-gerador.png" alt="unit-test-gerador" /></p><p style="text-align: justify;">Com esse resultado podemos ver que essa geração é extremamente rápida.</p><p style="text-align: justify;">Agora vamos então criar a classe que irá gerar os textos, usando concatenação de strings ou <code class="language-plaintext highlighter-rouge">StringBuilder</code>.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TextGenerator</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">generateParagraphsTextWithStringConcat</span><span class="o">(</span><span class="kt">int</span> <span class="n">paragraphCount</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">text</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">paragraphCount</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="nc">LoremIpsum</span><span class="o">.</span><span class="na">random</span><span class="o">().</span><span class="na">getText</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">text</span><span class="o">;</span>
    <span class="o">}</span>
	
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">generateParagraphsTextWithStringBuilder</span><span class="o">(</span><span class="kt">int</span> <span class="n">paragraphCount</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">var</span> <span class="n">text</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">paragraphCount</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">text</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="nc">LoremIpsum</span><span class="o">.</span><span class="na">random</span><span class="o">().</span><span class="na">getText</span><span class="o">());</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">text</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p style="text-align: justify;">A classe acima possui somente dois métodos estáticos que fazem a mesma coisa: receber uma quantidade de parágrafos por parâmetro e então gerar textos aleatórios usando junções de parágrafos providos por <code class="language-plaintext highlighter-rouge">LoremIpsum.random()</code>, de acordo com a quantidade de parágrafos definida.</p><p style="text-align: justify;">E agora vamos aos teste finais.</p><p style="text-align: justify;">Os testes consistirão também de testes unitários, que irão gerar o texto com uma quantidade definida de parágrafos e depois testar a quantidade de quebras de linha no texto.</p><p style="text-align: justify;">Inicialmente vamos usar uma quantidade de cem parágrafos e ver o resultado.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TextGeneratorTest</span> <span class="o">{</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">cemParagrafosDeTextoComStringConcat</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">var</span> <span class="n">text</span> <span class="o">=</span> <span class="nc">TextGenerator</span><span class="o">.</span><span class="na">generateParagraphsTextWithStringConcat</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
        <span class="n">assertEquals</span><span class="o">(</span><span class="mi">100</span><span class="o">,</span> <span class="n">text</span><span class="o">.</span><span class="na">chars</span><span class="o">().</span><span class="na">filter</span><span class="o">(</span><span class="n">ch</span> <span class="o">-&gt;</span> <span class="n">ch</span> <span class="o">==</span> <span class="sc">'\n'</span><span class="o">).</span><span class="na">count</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">cemParagrafosDeTextoComStringBuilder</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">var</span> <span class="n">text</span> <span class="o">=</span> <span class="nc">TextGenerator</span><span class="o">.</span><span class="na">generateParagraphsTextWithStringBuilder</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
        <span class="n">assertEquals</span><span class="o">(</span><span class="mi">100</span><span class="o">,</span> <span class="n">text</span><span class="o">.</span><span class="na">chars</span><span class="o">().</span><span class="na">filter</span><span class="o">(</span><span class="n">ch</span> <span class="o">-&gt;</span> <span class="n">ch</span> <span class="o">==</span> <span class="sc">'\n'</span><span class="o">).</span><span class="na">count</span><span class="o">());</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></table></code></div></div><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/concatenacao-de-strings-e-performance/unit-test-cem.png" alt="unit-test-cem" /></p><p style="text-align: justify;">Podemos ver na imagem que o tempo de execução foi o mesmo para as duas abordagens: 0,000 segundos.</p><p style="text-align: justify;">Será que então realmente não têm diferença entre elas? Vamos utilizar mil parágrafos no próximo teste.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TextGeneratorTest</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">milParagrafosDeTextoComStringConcat</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">var</span> <span class="n">text</span> <span class="o">=</span> <span class="nc">TextGenerator</span><span class="o">.</span><span class="na">generateParagraphsTextWithStringConcat</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
        <span class="n">assertEquals</span><span class="o">(</span><span class="mi">1000</span><span class="o">,</span> <span class="n">text</span><span class="o">.</span><span class="na">chars</span><span class="o">().</span><span class="na">filter</span><span class="o">(</span><span class="n">ch</span> <span class="o">-&gt;</span> <span class="n">ch</span> <span class="o">==</span> <span class="sc">'\n'</span><span class="o">).</span><span class="na">count</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">milParagrafosDeTextoComStringBuilder</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">var</span> <span class="n">text</span> <span class="o">=</span> <span class="nc">TextGenerator</span><span class="o">.</span><span class="na">generateParagraphsTextWithStringBuilder</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
        <span class="n">assertEquals</span><span class="o">(</span><span class="mi">1000</span><span class="o">,</span> <span class="n">text</span><span class="o">.</span><span class="na">chars</span><span class="o">().</span><span class="na">filter</span><span class="o">(</span><span class="n">ch</span> <span class="o">-&gt;</span> <span class="n">ch</span> <span class="o">==</span> <span class="sc">'\n'</span><span class="o">).</span><span class="na">count</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/concatenacao-de-strings-e-performance/unit-test-mil.png" alt="unit-test-mil" /></p><p style="text-align: justify;">Opa! Agora parece que já temos uma pequena diferença, onde a abordagem com o <code class="language-plaintext highlighter-rouge">StringBuilder</code> continua com 0,000 segundos, mas a concatenação já está levando 419 milissegundos (0,419 segundos) de execução.</p><p style="text-align: justify;">Porém isso ainda não é algo que realmente faça tanta diferença assim para que seja uma recomendação levada a sério.</p><p style="text-align: justify;">Vamos então subir um pouco mais a quantidade de parágrafos no nosso teste final: dez mil.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TextGeneratorTest</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">dezMilParagrafosDeTextoComStringConcat</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">var</span> <span class="n">text</span> <span class="o">=</span> <span class="nc">TextGenerator</span><span class="o">.</span><span class="na">generateParagraphsTextWithStringConcat</span><span class="o">(</span><span class="mi">10000</span><span class="o">);</span>
        <span class="n">assertEquals</span><span class="o">(</span><span class="mi">10000</span><span class="o">,</span> <span class="n">text</span><span class="o">.</span><span class="na">chars</span><span class="o">().</span><span class="na">filter</span><span class="o">(</span><span class="n">ch</span> <span class="o">-&gt;</span> <span class="n">ch</span> <span class="o">==</span> <span class="sc">'\n'</span><span class="o">).</span><span class="na">count</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">dezMilParagrafosDeTextoComStringBuilder</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">var</span> <span class="n">text</span> <span class="o">=</span> <span class="nc">TextGenerator</span><span class="o">.</span><span class="na">generateParagraphsTextWithStringBuilder</span><span class="o">(</span><span class="mi">10000</span><span class="o">);</span>
        <span class="n">assertEquals</span><span class="o">(</span><span class="mi">10000</span><span class="o">,</span> <span class="n">text</span><span class="o">.</span><span class="na">chars</span><span class="o">().</span><span class="na">filter</span><span class="o">(</span><span class="n">ch</span> <span class="o">-&gt;</span> <span class="n">ch</span> <span class="o">==</span> <span class="sc">'\n'</span><span class="o">).</span><span class="na">count</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/concatenacao-de-strings-e-performance/unit-test-dez-mil.png" alt="unit-test-dez-mil" /></p><p style="text-align: justify;">E então finalmente temos nossa grande diferença. Usando o <code class="language-plaintext highlighter-rouge">StringBuilder</code> temos um tempo de execução de 0,007 segundos (7 milissegundos), enquanto que a concatenação levou longos 26,220 segundos, um tempo imensamente maior que o da primeira abordagem, o que comprova que realmente o <code class="language-plaintext highlighter-rouge">StringBuilder</code> é a melhor alternativa principalmente para textos longos.</p><p style="text-align: justify;">Mas por quê isso acontece?</p><h2 id="entendendo-strings">Entendendo strings</h2><p style="text-align: justify;">Antes de falar sobre o problema vamos mostrar algumas coisas sobre as strings e como elas funcionam.</p><p style="text-align: justify;">A maioria das linguagens (principalmente as compiladas) possuem diferentes tipos de atributos, geralmente chamados de tipos de variáveis, onde eles são separados em <strong>primitivos</strong> e <strong>complexos</strong>.</p><p style="text-align: justify;">Os primitivos são os tipos mais básicos das linguagens, no caso do Java eles são a menor representação que um tipo pode ter, que são os tipos <code class="language-plaintext highlighter-rouge">int, short, long, byte, float, double, boolean, char</code> e etc, e os tipos complexos são definições criadas utilizando a linguagem e que agrupam e/ou manusei am esses tipos primitivos, onde em Java as classes, enums e interfaces são utilizadas para esse propósito. Para exemplificar podemos ter os atributos primitivos <code class="language-plaintext highlighter-rouge">int codigo</code> e <code class="language-plaintext highlighter-rouge">double valor</code> para representar o código e valor de um produto, e podemos então criar um tipo complexo que é uma classe <code class="language-plaintext highlighter-rouge">Produto</code> contendo esses atributos primitivos, o que nos permite manusear os tipos primitivos de forma agrupada no tipo complexo.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Produto</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">codigo</span><span class="o">;</span>
    <span class="kt">double</span> <span class="n">valor</span><span class="o">;</span>
<span class="o">}</span>

<span class="kt">var</span> <span class="n">produto</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Produto</span><span class="o">();</span>
<span class="n">produto</span><span class="o">.</span><span class="na">codigo</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
<span class="n">produto</span><span class="o">.</span><span class="na">valor</span> <span class="o">=</span> <span class="mf">10.0</span><span class="o">;</span>
</pre></table></code></div></div><p style="text-align: justify;">As strings em Java funcionam dessa mesma forma, onde uma <code class="language-plaintext highlighter-rouge">String</code> é uma classe que representa um conjunto de letras, armazenadas no formato de um vetor de caracteres, ou seja um <code class="language-plaintext highlighter-rouge">char[] texto</code>.</p><p style="text-align: justify;">Basicamente quando uma <code class="language-plaintext highlighter-rouge">String</code> é declarada, internamente é criado um vetor contendo os caracteres do texto e esse vetor nunca muda, pois as strings são imutáveis, ou seja não podem ser modificadas, e isso implica na fato de que sempre que duas strings são concatenadas é então produzida uma terceira string.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nc">String</span> <span class="n">nome</span> <span class="o">=</span> <span class="s">"Murilo "</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">sobrenome</span> <span class="o">=</span> <span class="s">"Costa"</span><span class="o">;</span>
<span class="n">nome</span> <span class="o">=</span> <span class="n">nome</span> <span class="o">+</span> <span class="n">sobrenome</span><span class="o">;</span>
</pre></table></code></div></div><p style="text-align: justify;">Internamente aqui foram construídos três espaços de memória, o primeiro para representar a string <code class="language-plaintext highlighter-rouge">"Murilo "</code>, que foi atribuída a variável <code class="language-plaintext highlighter-rouge">nome</code>, o segundo para representar a string <code class="language-plaintext highlighter-rouge">"Costa"</code>, atribuída a variável <code class="language-plaintext highlighter-rouge">sobrenome</code> e então foi criado o último espaço de memória para armazenar os dois valores juntos, reatribuindo o novo valor na variável <code class="language-plaintext highlighter-rouge">nome</code>.</p><p style="text-align: justify;">Existem outras coisas importantes ao se falar sobre strings em Java, como o fato delas serem <code class="language-plaintext highlighter-rouge">UTF-16</code>, o mecanismo de internalização que otimiza drasticamente o reúso de strings, mas esses assuntos não vem ao caso de hoje.</p><h2 id="o-problema-da-concatenção">O problema da concatenção</h2><p style="text-align: justify;">O grande vilão da concatenação de strings aqui está justamente no fato de strings serem imutáveis, o que acaba indiretamente gerando um processo duplicado a cada concatenação realizada. Como falei anteriormente, a concatenação de duas strings sempre produz uma terceira string, que é a junção das duas, e nessa junção basicamente se cria um novo vetor de caracteres com tamanho suficiente para as duas strings e se copia o valor das duas caractere a caractere para a nova string.</p><p style="text-align: justify;">O código executado é semelhante ao código abaixo.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">concatenate</span><span class="o">(</span><span class="nc">String</span> <span class="n">s1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">s2</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">char</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="n">s1</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
    <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
	
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s1</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">result</span><span class="o">[</span><span class="n">pos</span><span class="o">++]</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="na">chartAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">result</span><span class="o">[</span><span class="n">pos</span><span class="o">++]</span> <span class="o">=</span> <span class="n">s2</span><span class="o">.</span><span class="na">chartAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><p style="text-align: justify;">Por esse código percebemos que sempre vamos ter que percorrer as duas strings que são concatenadas por inteiro, e se verificarmos o código de concatenação utilizado nos testes anteriores vamos ver que esse processo se repete utilizando sempre o resultado da última concatenação, o que implica em novamente sempre percorrer a mesma string por inteiro em cada concatenação.</p><p style="text-align: justify;">Para facilitar vamos reescrever o código do teste realizando a concatenação a partir do código acima.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">generateParagraphsTextWithStringConcat</span><span class="o">(</span><span class="kt">int</span> <span class="n">paragraphCount</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">text</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">paragraphCount</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">paragraph</span> <span class="o">=</span> <span class="nc">LoremIpsum</span><span class="o">.</span><span class="na">random</span><span class="o">().</span><span class="na">getText</span><span class="o">();</span> <span class="c1">//novo parágrafo</span>

        <span class="kt">char</span><span class="o">[]</span> <span class="n">newText</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="n">text</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="n">paragraph</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">text</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">//percore toda a string text novamente a cada concatenação</span>
            <span class="n">result</span><span class="o">[</span><span class="n">pos</span><span class="o">++]</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="na">chartAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">paragraph</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">result</span><span class="o">[</span><span class="n">pos</span><span class="o">++]</span> <span class="o">=</span> <span class="n">paragraph</span><span class="o">.</span><span class="na">chartAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="n">text</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">newText</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">text</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p style="text-align: justify;">Como pode ser visto no código anterior, para cada novo parágrafo adicionado o processo terá que percorrer toda a string <code class="language-plaintext highlighter-rouge">text</code> novamente, e é exatamente nesse ponto que a lentidão ocorre, pois quanto maior for a string <code class="language-plaintext highlighter-rouge">text</code> mais tempo essa cópia irá levar.</p><p style="text-align: justify;">Agora ficou mais fácil de entender o que ocorre internamente, não é mesmo? E quando temos um processo desse com instruções de loop (for) aninhadas, ou seja uma dentro da outra, processando o mesmo valor, temos um algoritmo de ordem <code class="language-plaintext highlighter-rouge">Big O(n²)</code>, que é uma execução lenta comparada a outras performances.</p><p style="text-align: justify;">E por que isso não ocorre no <code class="language-plaintext highlighter-rouge">StringBuilder</code>?</p><p style="text-align: justify;">O <code class="language-plaintext highlighter-rouge">StringBuilder</code> trabalha de uma forma diferente, onde ele armazena uma espécie de lista strings que não são concatenadas durante a adição, sendo que isso ocorre somente ao chamar algum método que utilize seu valor, como é o caso do <code class="language-plaintext highlighter-rouge">toString()</code>. E é por isso que esse problema de performance não ocorre, pois cada inserção no <code class="language-plaintext highlighter-rouge">StringBuilder</code> não necessita percorrer todas as outras strings.</p><p style="text-align: justify;">A implementação por baixo dos panos com o <code class="language-plaintext highlighter-rouge">StringBuilder</code> seria mais ou menos assim.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">generateParagraphsTextWithStringBuilder</span><span class="o">(</span><span class="kt">int</span> <span class="n">paragraphCount</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">var</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;();</span>
    <span class="kt">var</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">paragraphCount</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">paragraph</span> <span class="o">=</span> <span class="nc">LoremIpsum</span><span class="o">.</span><span class="na">random</span><span class="o">().</span><span class="na">getText</span><span class="o">();</span> <span class="c1">//novo parágrafo</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="n">paragraph</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">paragraph</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kt">char</span><span class="o">[]</span> <span class="n">text</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="n">size</span><span class="o">];</span>

    <span class="kt">var</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">s</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">//só concatena no final</span>
            <span class="n">text</span><span class="o">[</span><span class="n">pos</span><span class="o">++]</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">chartAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="n">text</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><p style="text-align: justify;">Podemos perceber que nessa implementação não precisamos percorrer toda a string a cada novo parágrafo adicionado, onde a criação da nova string só ocorre no final juntando todas as strings adicionadas na lista, o que configura um algoritmo de ordem <code class="language-plaintext highlighter-rouge">Big O(n)</code>, muito mais performático que o anterior.</p><p style="text-align: justify;"><em>Obs: Existe uma explicação matemática mais precisa para configurar a ordem dos algoritmos citados acima, porém são explicações que envolvem teorias matemáticas que eu não quero trazer para cá, então caso você queira entender um pouco melhor isso, é possível encontrar essas explicações em buscas na internet, como essa <a href="https://www.reddit.com/r/learnprogramming/comments/4uh2b6/comment/d5pogj8/?utm_source=share&amp;utm_medium=web2x&amp;context=3" target="_blank">aqui</a>.</em></p><p style="text-align: justify;">E é por isso que, pelo menos em Java, sempre devemos dar preferência ao <code class="language-plaintext highlighter-rouge">StringBuilder</code> para concatenar strings ao invés da concatenação tradicional.</p><p>Agora fica uma última pergunta: Se esse problema ocorre justamente pelo fato de strings serem imutáveis, por que ela são assim? Isso já é assunto para outro post :).</p><h2 id="bônus-stringbuilder-x-stringbuffer-em-java">Bônus: StringBuilder x StringBuffer em Java</h2><p style="text-align: justify;">Em Java, além do <code class="language-plaintext highlighter-rouge">StringBuilder</code> existe também uma outra classe chamada <code class="language-plaintext highlighter-rouge">StringBuffer</code> para realizar concatenações de strings de forma mais performática, onde as duas funcionam basicamente da mesma forma. A maior diferença entre elas é que o <code class="language-plaintext highlighter-rouge">StringBuffer</code> é mais antigo e ele possui uma serie de locks para uso com processo multi-thread, onde seu uso é desaconselhado em casos single-thread.</p><p style="text-align: justify;">E é exatamente por essa característica que não é aconselhável utilizar o <code class="language-plaintext highlighter-rouge">StringBuffer</code> em processos que não tenham concorrência, pois esses locks podem prejudicar um pouco o desempenho do processo.</p><p style="text-align: justify;">Vamos ver as implementações usando cada um e seus testes para compararmos os resultados.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">generateParagraphsTextWithStringBuilder</span><span class="o">(</span><span class="kt">int</span> <span class="n">paragraphCount</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">var</span> <span class="n">text</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">paragraphCount</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">text</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="nc">LoremIpsum</span><span class="o">.</span><span class="na">random</span><span class="o">().</span><span class="na">getText</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">text</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">generateParagraphsTextWithStringBuffer</span><span class="o">(</span><span class="kt">int</span> <span class="n">paragraphCount</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">var</span> <span class="n">text</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuffer</span><span class="o">();</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">paragraphCount</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">text</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="nc">LoremIpsum</span><span class="o">.</span><span class="na">random</span><span class="o">().</span><span class="na">getText</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">text</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">dezMilParagrafosDeTextoComStringBuilder</span><span class="o">()</span> <span class="o">{</span>
    <span class="kt">var</span> <span class="n">text</span> <span class="o">=</span> <span class="nc">TextGenerator</span><span class="o">.</span><span class="na">generateParagraphsTextWithStringBuilder</span><span class="o">(</span><span class="mi">10000</span><span class="o">);</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="mi">10000</span><span class="o">,</span> <span class="n">text</span><span class="o">.</span><span class="na">chars</span><span class="o">().</span><span class="na">filter</span><span class="o">(</span><span class="n">ch</span> <span class="o">-&gt;</span> <span class="n">ch</span> <span class="o">==</span> <span class="sc">'\n'</span><span class="o">).</span><span class="na">count</span><span class="o">());</span>
<span class="o">}</span>

<span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">dezMilParagrafosDeTextoComStringBuffer</span><span class="o">()</span> <span class="o">{</span>
    <span class="kt">var</span> <span class="n">text</span> <span class="o">=</span> <span class="nc">TextGenerator</span><span class="o">.</span><span class="na">generateParagraphsTextWithStringBuffer</span><span class="o">(</span><span class="mi">10000</span><span class="o">);</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="mi">10000</span><span class="o">,</span> <span class="n">text</span><span class="o">.</span><span class="na">chars</span><span class="o">().</span><span class="na">filter</span><span class="o">(</span><span class="n">ch</span> <span class="o">-&gt;</span> <span class="n">ch</span> <span class="o">==</span> <span class="sc">'\n'</span><span class="o">).</span><span class="na">count</span><span class="o">());</span>
<span class="o">}</span>
</pre></table></code></div></div><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/posts/concatenacao-de-strings-e-performance/unit-test-stringbuffer.png" alt="unit-test-stringbuffer" /></p><p style="text-align: justify;">Como é possível ver, a diferença no tempo de execução é pouca, mas ela ainda existe, e dependendo da complexidade do seu código isso pode se tornar um problema.</p><p>E é isso aí pessoal, até a próxima.</p><p style="text-align: justify;">Ah, os códigos podem ser obtidos <a href="https://github.com/murilo-ramos/murilo-tech/tree/master/stringsconcatbuilder" target="_blank">aqui</a>.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/blogging/'>Blogging</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/string/" class="post-tag no-text-decoration" >string</a> <a href="/tags/java/" class="post-tag no-text-decoration" >java</a> <a href="/tags/big-o/" class="post-tag no-text-decoration" >big-o</a> <a href="/tags/performance/" class="post-tag no-text-decoration" >performance</a> <a href="/tags/concat/" class="post-tag no-text-decoration" >concat</a> <a href="/tags/stringbuilder/" class="post-tag no-text-decoration" >stringbuilder</a> <a href="/tags/stringbuffer/" class="post-tag no-text-decoration" >stringbuffer</a> <a href="/tags/concatenacao/" class="post-tag no-text-decoration" >concatenacao</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> Este post está licenciado sob a <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> pelo autor.</div><!-- Post sharing snippet v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT License --><div class="share-wrapper"> <span class="share-label text-muted mr-1">Compartilhar</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Concatenação de strings e performance - murilo.tech&url=https://murilo.tech/posts/concatenacao-de-strings-e-performance/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Concatenação de strings e performance - murilo.tech&u=https://murilo.tech/posts/concatenacao-de-strings-e-performance/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Concatenação de strings e performance - murilo.tech&url=https://murilo.tech/posts/concatenacao-de-strings-e-performance/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://murilo.tech/posts/concatenacao-de-strings-e-performance/" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank"> <i class="fa-fw fab fa-linkedin"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><!-- The Pannel on right side (Desktop views) v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><h3 data-toc-skip>Atualizações Recentes</h3><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/criptografia/">Criptografia</a></li><li><a href="/posts/testes-unitarios-com-spring-usando-mock/">Testes unitários com Spring Framework usando mock</a></li><li><a href="/posts/estrategias-para-testes-unitarios/">Estratégias para testes unitários</a></li><li><a href="/posts/refatorando-e-alcancando-codigo-limpo/">Refatorando e alcançando um código limpo</a></li><li><a href="/posts/ferramentas-para-o-ambiente-de-desenvolvimento/">Ferramentas para o ambiente de desenvolvimento</a></li></ul></div><div id="access-tags"><h3 data-toc-skip>Tags Populares</h3><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/programacao/">programacao</a> <a class="post-tag" href="/tags/murilo-tech/">murilo tech</a> <a class="post-tag" href="/tags/murilo/">murilo</a> <a class="post-tag" href="/tags/historia/">historia</a> <a class="post-tag" href="/tags/github/">github</a> <a class="post-tag" href="/tags/software/">software</a> <a class="post-tag" href="/tags/relato/">relato</a> <a class="post-tag" href="/tags/mysql/">mysql</a> <a class="post-tag" href="/tags/maven/">maven</a> <a class="post-tag" href="/tags/jekyll/">jekyll</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><h3 data-toc-skip class="pl-3 pt-2 mb-2">Conteúdo</h3><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"> <!-- Recommend the other 3 posts according to the tags and categories of the current post, if the number is not enough, use the other latest posts to supplement. v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung Published under the MIT License --><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Para Ler Depois</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/coisas-que-aprendi-estudando-certificacao-java/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > May 4, 2021 <i class="unloaded">2021-05-04T17:30:00-03:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Coisas que aprendi estudando para a certificação Java</h3><div class="text-muted small"><p> Como alguns viram, no último mês de abril foi aniversário da linguagem de programação Java, a linguagem que mais venho utilizando desde meu início de carreira, que está completando 25 anos de idade...</p></div></div></a></div><div class="card"> <a href="/posts/causo-minha-primeira-parada-em-producao/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Oct 25, 2021 <i class="unloaded">2021-10-25T08:00:00-03:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Causo - A minha primeira parada em produção</h3><div class="text-muted small"><p> Hoje estou inaugurando uma seção nesse blog para contar e relatar histórias que vivi atuando como um profissional na área de desenvolvimento de software, ou como gosto de chamar: Os famosos causos!...</p></div></div></a></div><div class="card"> <a href="/posts/testando-envio-emails-com-fakesmtp/"><div class="card-body"> <!-- Date format snippet v2.4.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --> <span class="timeago small" > Dec 7, 2021 <i class="unloaded">2021-12-07T17:20:00-03:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Testando envio de e-mails com Fake SMTP</h3><div class="text-muted small"><p> Como eu já mencionei anteriormente em alguns posts, a maioria dos softwares que desenvolvemos sempre possui algum tipo de dependência de outros serviços e mecanismos, onde precisamos realizar integ...</p></div></div></a></div></div></div><!-- Navigation buttons at the bottom of the post. v2.1 https://github.com/cotes2020/jekyll-theme-chirpy © 2020 Cotes Chung MIT License --><div class="post-navigation d-flex justify-content-between"> <a href="/posts/testando-envio-emails-com-fakesmtp/" class="btn btn-outline-primary"><p>Testando envio de e-mails com Fake SMTP</p></a> <a href="/posts/causo-o-dia-que-apaguei-o-banco-de-dados-de-producao/" class="btn btn-outline-primary"><p>Causo - O dia que apaguei o banco de dados de produção</p></a></div><!-- The Disqus lazy loading. Powered by: https://osvaldas.info/lazy-loading-disqus-comments v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2019 Cotes Chung MIT License --><div id="disqus" class="pt-2 pb-2"><p class="font-italic text-center text-muted small"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> var options = { scriptUrl: '//murilo-tech.disqus.com/embed.js', disqusConfig: function() { this.page.url = 'https://murilo.tech/posts/concatenacao-de-strings-e-performance/'; this.page.identifier = '/posts/concatenacao-de-strings-e-performance/'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('#post-wrapper img'); const observer = lozad(imgs); observer.observe(); </script> <!-- The Footer v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://twitter.com/muriloramosdc">Murilo Costa</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Alguns direitos reservados.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy/">Chirpy</a> theme.</p></div></div></footer></div><!-- The Search results v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Tags Populares</h4><a class="post-tag" href="/tags/programacao/">programacao</a> <a class="post-tag" href="/tags/murilo-tech/">murilo tech</a> <a class="post-tag" href="/tags/murilo/">murilo</a> <a class="post-tag" href="/tags/historia/">historia</a> <a class="post-tag" href="/tags/github/">github</a> <a class="post-tag" href="/tags/software/">software</a> <a class="post-tag" href="/tags/relato/">relato</a> <a class="post-tag" href="/tags/mysql/">mysql</a> <a class="post-tag" href="/tags/maven/">maven</a> <a class="post-tag" href="/tags/jekyll/">jekyll</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <!-- The GA snippet v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-54279404-2', 'auto'); ga('send', 'pageview'); </script> <!-- Jekyll Simple Search loader v2.0 https://github.com/cotes2020/jekyll-theme-chirpy © 2017-2019 Cotes Chung MIT License --> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://murilo.tech{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
